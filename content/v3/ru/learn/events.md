# Система событий в Flight PHP (v3.15.0+)

Flight PHP вводит легкую и интуитивно понятную систему событий, которая позволяет вам регистрировать и вызывать пользовательские события в вашем приложении. С добавлением `Flight::onEvent()` и `Flight::triggerEvent()` вы теперь можете подключаться к ключевым моментам жизненного цикла вашего приложения или определять свои собственные события, чтобы сделать ваш код более модульным и расширяемым. Эти методы являются частью **картиируемых методов** Flight, что означает, что вы можете переопределить их поведение в соответствии с вашими потребностями.

Этот гид охватывает все, что вам нужно знать, чтобы начать работать с событиями, включая причины их ценности, как их использовать и практические примеры, помогающие новичкам понять их мощь.

## Зачем использовать события?

События позволяют вам разделить разные части вашего приложения так, чтобы они не зависели друг от друга слишком сильно. Это разделение, часто называемое **развязкой**, делает ваш код более простым в обновлении, расширении или отладке. Вместо того, чтобы писать все в одном большом куске, вы можете разделить вашу логику на более мелкие, независимые части, которые реагируют на конкретные действия (события).

Представьте, что вы строите блог-приложение:
- Когда пользователь публикует комментарий, вы можете захотеть:
  - Сохранить комментарий в базе данных.
  - Отправить электронное письмо владельцу блога.
  - Записать действие для безопасности.

Без событий вы бы запихнули все это в одну функцию. С событиями вы можете разделить это: одна часть сохраняет комментарий, другая инициирует событие, такое как `'comment.posted'`, а отдельные слушатели обрабатывают отправку электронного письма и ведение журнала. Это делает ваш код чище и позволяет вам добавлять или удалять функции (например, уведомления) без обращения к основной логике.

### Общие применения
- **Ведение журнала**: Записывайте действия, такие как входы или ошибки, не перегружая ваш основной код.
- **Уведомления**: Отправляйте электронные письма или оповещения, когда что-то происходит.
- **Обновления**: Обновляйте кэши или уведомляйте другие системы о изменениях.

## Регистрация слушателей событий

Чтобы прослушивать событие, используйте `Flight::onEvent()`. Этот метод позволяет вам определить, что должно произойти, когда событие срабатывает.

### Синтаксис
```php
Flight::onEvent(string $event, callable $callback): void
```
- `$event`: Имя вашего события (например, `'user.login'`).
- `$callback`: Функция, которая будет запущена при срабатывании события.

### Как это работает
Вы "подписываетесь" на событие, сообщая Flight, что делать, когда оно происходит. Колбек может принимать аргументы, переданные от инициатора события.

Система событий Flight является синхронной, что означает, что каждый слушатель события выполняется в последовательности, один за другим. Когда вы инициируете событие, все зарегистрированные слушатели этого события будут выполнены до завершения, прежде чем ваш код продолжится. Это важно понимать, так как это отличается от асинхронных систем событий, где слушатели могут выполняться параллельно или в более позднее время.

### Простой пример
```php
Flight::onEvent('user.login', function ($username) {
    echo "Добро пожаловать обратно, $username!";
});
```
В этом примере, когда событие `'user.login'` будет инициировано, оно поприветствует пользователя по имени.

### Ключевые моменты
- Вы можете добавить несколько слушателей к одному и тому же событию — они будут выполняться в порядке вашей регистрации.
- Колбек может быть функцией, анонимной функцией или методом из класса.

## Инициирование событий

Чтобы инициировать событие, используйте `Flight::triggerEvent()`. Это говорит Flight выполнить все слушатели, зарегистрированные для этого события, передавая любые данные, которые вы предоставляете.

### Синтаксис
```php
Flight::triggerEvent(string $event, ...$args): void
```
- `$event`: Имя события, которое вы инициируете (должно совпадать с зарегистрированным событием).
- `...$args`: Необязательные аргументы для передачи слушателям (может быть любое количество аргументов).

### Простой пример
```php
$username = 'alice';
Flight::triggerEvent('user.login', $username);
```
Это инициирует событие `'user.login'` и отправляет `'alice'` слушателю, который мы определили ранее, который выведет: `Добро пожаловать обратно, alice!`.

### Ключевые моменты
- Если не зарегистрированы слушатели, ничего не происходит — ваше приложение не сломается.
- Используйте оператор распаковки (`...`), чтобы гибко передавать несколько аргументов.

### Регистрация слушателей событий

...

**Остановка дальнейших слушателей**:
Если слушатель возвращает `false`, то никакие дополнительные слушатели для этого события не будут выполнены. Это позволяет вам остановить цепочку событий на основе специфических условий. Помните, что порядок слушателей важен, так как первый, кто вернет `false`, остановит выполнение остальных.

**Пример**:
```php
Flight::onEvent('user.login', function ($username) {
    if (isBanned($username)) {
        logoutUser($username);
        return false; // Останавливает последующие слушатели
    }
});
Flight::onEvent('user.login', function ($username) {
    sendWelcomeEmail($username); // это никогда не будет отправлено
});
```

## Переопределение методов событий

`Flight::onEvent()` и `Flight::triggerEvent()` могут быть [расширены](/learn/extending), что позволяет вам переопределить, как они работают. Это отлично подходит для опытных пользователей, которые хотят настроить систему событий, например, добавляя ведение журнала или изменяя способ отправки событий.

### Пример: Настройка `onEvent`
```php
Flight::map('onEvent', function (string $event, callable $callback) {
    // Вести учет каждой регистрации события
    error_log("Добавлен новый слушатель событий для: $event");
    // Вызвать стандартное поведение (предполагая внутреннюю систему событий)
    Flight::_onEvent($event, $callback);
});
```
Теперь каждый раз, когда вы регистрируете событие, оно будет логироваться перед продолжением.

### Зачем переопределять?
- Добавить отладку или мониторинг.
- Ограничить события в определенных средах (например, отключить в тестировании).
- Интегрировать с другой библиотекой событий.

## Где размещать ваши события

Как новичку, вам может быть интересно: *где регистрировать все эти события в моем приложении?* Простота Flight означает, что нет строгого правила — вы можете размещать их везде, где это имеет смысл для вашего проекта. Однако их организацией помогает вам поддерживать код в порядке, по мере роста вашего приложения. Вот несколько практических вариантов и лучшие практики, адаптированные к легковесной природе Flight:

### Вариант 1: В вашем основном файле `index.php`
Для небольших приложений или быстрых прототипов вы можете регистрировать события прямо в вашем файле `index.php`, наряду с вашими маршрутами. Это позволяет держать все в одном месте, что вполне приемлемо, когда простота является приоритетом.

```php
require 'vendor/autoload.php';

// Регистрация событий
Flight::onEvent('user.login', function ($username) {
    error_log("$username вошел в систему в " . date('Y-m-d H:i:s'));
});

// Определение маршрутов
Flight::route('/login', function () {
    $username = 'bob';
    Flight::triggerEvent('user.login', $username);
    echo "Вошел в систему!";
});

Flight::start();
```
- **Плюсы**: Просто, нет лишних файлов, отлично для небольших проектов.
- **Минусы**: Может стать неаккуратным по мере роста вашего приложения с большим количеством событий и маршрутов.

### Вариант 2: Отдельный файл `events.php`
Для немного большего приложения рассмотрите возможность перемещения регистрации событий в отдельный файл, такой как `app/config/events.php`. Включите этот файл в ваш `index.php` перед маршрутами. Это имитирует, как маршруты часто организованы в `app/config/routes.php` в проектах Flight.

```php
// app/config/events.php
Flight::onEvent('user.login', function ($username) {
    error_log("$username вошел в систему в " . date('Y-m-d H:i:s'));
});

Flight::onEvent('user.registered', function ($email, $name) {
    echo "Электронное письмо отправлено на $email: Добро пожаловать, $name!";
});
```

```php
// index.php
require 'vendor/autoload.php';
require 'app/config/events.php';

Flight::route('/login', function () {
    $username = 'bob';
    Flight::triggerEvent('user.login', $username);
    echo "Вошел в систему!";
});

Flight::start();
```
- **Плюсы**: Держит `index.php` сосредоточенным на маршрутизации, логично организует события, легко находит и редактирует.
- **Минусы**: Добавляет небольшой уровень структуры, который может показаться излишним для очень маленьких приложений.

### Вариант 3: Поблизости от места их срабатывания
Другой подход — регистрировать события близко к тому месту, где они срабатывают, например, внутри контроллера или определения маршрута. Это хорошо работает, если событие специфично для одной части вашего приложения.

```php
Flight::route('/signup', function () {
    // Зарегистрировать событие здесь
    Flight::onEvent('user.registered', function ($email) {
        echo "Отправлено приветственное письмо на $email!";
    });

    $email = 'jane@example.com';
    Flight::triggerEvent('user.registered', $email);
    echo "Зарегистрировался!";
});
```
- **Плюсы**: Держит связанный код вместе, хорошо для изолированных функций.
- **Минусы**: Разбрасывает регистрации событий, усложняя обзор всех событий; рискует дублировать регистрации, если не быть осторожным.

### Лучшие практики для Flight
- **Начните с простоты**: Для крошечных приложений помещайте события в `index.php`. Это быстро и соответствует минимализму Flight.
- **Развивайтесь разумно**: По мере роста вашего приложения (например, более 5-10 событий) используйте файл `app/config/events.php`. Это естественный шаг вверх, как и организация маршрутов, и сохраняет ваш код аккуратным без добавления сложных фреймворков.
- **Избегайте чрезмерного проектирования**: Не создавайте класс или каталог «менеджера событий» без особой нужды — Flight преуспевает в простоте, так что сохраняйте всё легковесным.

### Совет: Группируйте по цели
В `events.php` группируйте связанные события (например, все события, связанные с пользователями, вместе) с комментариями для ясности:

```php
// app/config/events.php
// События пользователей
Flight::onEvent('user.login', function ($username) {
    error_log("$username вошел в систему");
});
Flight::onEvent('user.registered', function ($email) {
    echo "Добро пожаловать на $email!";
});

// События страниц
Flight::onEvent('page.updated', function ($pageId) {
    unset($_SESSION['pages'][$pageId]);
});
```

Эта структура хорошо масштабируется и остается дружелюбной для новичков.

## Примеры для новичков

Давайте рассмотрим несколько реальных сценариев, чтобы показать, как работают события и почему они полезны.

### Пример 1: Ведение учета входа пользователя
```php
// Шаг 1: Зарегистрировать слушателя
Flight::onEvent('user.login', function ($username) {
    $time = date('Y-m-d H:i:s');
    error_log("$username вошел в систему в $time");
});

// Шаг 2: Инициировать это в вашем приложении
Flight::route('/login', function () {
    $username = 'bob'; // Предположим, что это приходит из формы
    Flight::triggerEvent('user.login', $username);
    echo "Привет, $username!";
});
```
**Почему это полезно**: Код входа не должен беспокоиться о ведении журнала — он просто инициирует событие. Позже вы можете добавить больше слушателей (например, отправить приветственное письмо) без изменения маршрута.

### Пример 2: Уведомление о новых пользователях
```php
// Слушатель для новых регистраций
Flight::onEvent('user.registered', function ($email, $name) {
    // Симуляция отправки электронного письма
    echo "Электронное письмо отправлено на $email: Добро пожаловать, $name!";
});

// Инициировать это, когда кто-то зарегистрируется
Flight::route('/signup', function () {
    $email = 'jane@example.com';
    $name = 'Jane';
    Flight::triggerEvent('user.registered', $email, $name);
    echo "Спасибо за регистрацию!";
});
```
**Почему это полезно**: Логика регистрации сосредоточена на создании пользователя, в то время как событие обрабатывает уведомления. Вы могли бы добавить больше слушателей (например, записывать регистрацию) позже.

### Пример 3: Очистка кэша
```php
// Слушатель для очистки кэша
Flight::onEvent('page.updated', function ($pageId) {
    unset($_SESSION['pages'][$pageId]); // Очистить кэш сессии, если это применимо
    echo "Кэш очищен для страницы $pageId.";
});

// Инициировать, когда страница редактируется
Flight::route('/edit-page/(@id)', function ($pageId) {
    // Предположим, мы обновили страницу
    Flight::triggerEvent('page.updated', $pageId);
    echo "Страница $pageId обновлена.";
});
```
**Почему это полезно**: Код редактирования не заботится о кэше — он просто сигнализирует о обновлении. Другие части приложения могут реагировать по мере необходимости.

## Лучшие практики

- **Ясно называйте события**: Используйте конкретные имена, такие как `'user.login'` или `'page.updated'`, чтобы было очевидно, что они делают.
- **Держите слушателей простыми**: Не ставьте медленные или сложные задачи в слушателях — держите ваше приложение быстрым.
- **Тестируйте ваши события**: Инициируйте их вручную, чтобы убедиться, что слушатели работают так, как ожидалось.
- **Используйте события разумно**: Они отлично подходят для разъединения, но слишком много может сделать ваш код трудным для понимания — используйте их, когда это имеет смысл.

Система событий в Flight PHP с `Flight::onEvent()` и `Flight::triggerEvent()` предоставляет вам простой, но мощный способ создания гибких приложений. Позволяя различным частям вашего приложения взаимодействовать друг с другом через события, вы можете поддерживать свой код организованным, повторно используемым и легким для расширения. Будь то ведение журнала действий, отправка уведомлений или управление обновлениями, события помогают вам делать это без запутывания вашей логики. Плюс к этому, с возможностью переопределения этих методов у вас есть свобода настраивать систему под ваши нужды. Начните с небольшого события и наблюдайте, как это преобразует структуру вашего приложения!

## Встроенные события

Flight PHP поставляется с несколькими встроенными событиями, которые вы можете использовать для подключения к жизненному циклу фреймворка. Эти события инициируются в конкретные моменты в цикле запроса/ответа, позволяя вам выполнять пользовательскую логику, когда происходят определенные действия.

### Список встроенных событий
- **flight.request.received**: `function(Request $request)` Инициируется, когда запрос получен, распарсен и обработан.
- **flight.error**: `function(Throwable $exception)` Инициируется, когда возникает ошибка в процессе обработки запроса.
- **flight.redirect**: `function(string $url, int $status_code)` Инициируется, когда выполняется перенаправление.
- **flight.cache.checked**: `function(string $cache_key, bool $hit, float $executionTime)` Инициируется, когда кэш проверяется для конкретного ключа и если кэш попадает или нет.
- **flight.middleware.before**: `function(Route $route)` Инициируется после выполнения промежуточного программного обеспечения перед ним.
- **flight.middleware.after**: `function(Route $route)` Инициируется после выполнения промежуточного программного обеспечения после него.
- **flight.middleware.executed**: `function(Route $route, $middleware, string $method, float $executionTime)` Инициируется после выполнения любого промежуточного программного обеспечения.
- **flight.route.matched**: `function(Route $route)` Инициируется, когда маршрут совпадает, но еще не выполнен.
- **flight.route.executed**: `function(Route $route, float $executionTime)` Инициируется после выполнения и обработки маршрута. `$executionTime` — это время, затраченное на выполнение маршрута (вызов контроллера и т.д.).
- **flight.view.rendered**: `function(string $template_file_path, float $executionTime)` Инициируется после рендеринга представления. `$executionTime` — это время, затраченное на рендеринг шаблона. **Примечание: Если вы переопределите метод `render`, вам нужно будет повторно инициировать это событие.**
- **flight.response.sent**: `function(Response $response, float $executionTime)` Инициируется после отправки ответа клиенту. `$executionTime` — это время, затраченное на создание ответа.