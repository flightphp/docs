# Система подій у Flight PHP (v3.15.0+)

Flight PHP впроваджує легку та інтуїтивно зрозумілу систему подій, яка дозволяє вам реєструвати та викликати користувацькі події у вашому додатку. Завдяки додаванню `Flight::onEvent()` та `Flight::triggerEvent()`, ви тепер можете підключатися до ключових моментів життєвого циклу вашого додатка або визначати власні події, щоб робити ваш код більш модульним та розширюваним. Ці методи є частиною **мапованих методів** Flight, що означає, що ви можете переопределити їхню поведінку відповідно до ваших потреб.

Цей посібник охоплює все, що вам потрібно знати для початку роботи з подіями, включаючи те, чому вони мають цінність, як їх використовувати та практичні приклади, які допоможуть новачкам зрозуміти їхню силу.

## Чому варто використовувати події?

Події дозволяють вам розділити різні частини вашого додатка так, щоб вони не залежали одна від одної занадто сильно. Це розділення, яке часто називають **декуплюванням**, полегшує оновлення, розширення або налагодження вашого коду. Замість того, щоб писати все в одному великому блоці, ви можете розділити вашу логіку на менші, незалежні частини, які реагують на конкретні дії (події).

Уявіть, що ви створюєте блог додаток:
- Коли користувач публікує коментар, ви можете захотіти:
  - Зберегти коментар у базі даних.
  - Відправити електронний лист власнику блогу.
  - Залогувати дію для безпеки.

Без подій ви були б змушені все це втиснути в одну функцію. З подіями ви можете розділити це: одна частина зберігає коментар, інша викликає подію, таку як `'comment.posted'`, а окремі слухачі обробляють електронну пошту та логування. Це робить ваш код чистішим і дозволяє додавати чи видаляти функції (такі як сповіщення) без втручання в основну логіку.

### Загальні використання
- **Логування**: Записуйте дії, такі як входи або помилки, без заповнення вашого основного коду.
- **Сповіщення**: Відправляйте електронні листи або сповіщення, коли щось відбувається.
- **Оновлення**: Оновлюйте кеші або сповіщайте інші системи про зміни.

## Реєстрація слухачів подій

Щоб слухати подію, використовуйте `Flight::onEvent()`. Цей метод дозволяє вам визначити, що повинно відбутися, коли подія виникає.

### Синтаксис
```php
Flight::onEvent(string $event, callable $callback): void
```
- `$event`: Ім'я вашої події (наприклад, `'user.login'`).
- `$callback`: Функція, яку потрібно виконати, коли подія викликається.

### Як це працює
Ви "підписуєтеся" на подію, кажучи Flight, що робити, коли це відбудеться. Колбек може приймати аргументи, передані з тригера події.

Система подій Flight є синхронною, що означає, що кожен слухач подій виконується послідовно, один за іншим. Коли ви викликаєте подію, всі зареєстровані слухачі для цієї події будуть запущені до завершення, перш ніж ваш код продовжить роботу. Це важливо зрозуміти, оскільки це відрізняється від асинхронних систем подій, де слухачі можуть виконуватися паралельно або в пізніший час.

### Простий приклад
```php
Flight::onEvent('user.login', function ($username) {
    echo "Ласкаво просимо назад, $username!";
});
```
Тут, коли подія `'user.login'` викликається, вона привітає користувача за ім'ям.

### Основні моменти
- Ви можете додати кілька слухачів до однієї події — вони виконуватимуться в порядку їх реєстрації.
- Колбек може бути функцією, анонімною функцією або методом з класу.

## Виклик подій

Щоб викликати подію, використовуйте `Flight::triggerEvent()`. Це говорить Flight виконати всі слухачі, зареєстровані для цієї події, передаючи будь-які дані, які ви надали.

### Синтаксис
```php
Flight::triggerEvent(string $event, ...$args): void
```
- `$event`: Ім'я події, яку ви викликаєте (повинно відповідати зареєстрованій події).
- `...$args`: Додаткові аргументи для передачі слухачам (може бути будь-яка кількість аргументів).

### Простий приклад
```php
$username = 'alice';
Flight::triggerEvent('user.login', $username);
```
Це викликає подію `'user.login'` і передає `'alice'` слухачеві, якого ми визначили раніше, який виведе: `Ласкаво просимо назад, alice!`.

### Основні моменти
- Якщо не зареєстровано слухачів, нічого не станеться — ваш додаток не зламається.
- Використовуйте оператор розподілу (`...`), щоб гнучко передавати кілька аргументів.

### Реєстрація слухачів подій

...

**Зупинка подальших слухачів**:
Якщо слухач повертає `false`, жоден з наступних слухачів для цієї події не буде виконаний. Це дозволяє вам зупинити ланцюг подій на основі конкретних умов. Пам'ятайте, що порядок слухачів має значення, оскільки перший, хто повертає `false`, зупинить решту від виконання.

**Приклад**:
```php
Flight::onEvent('user.login', function ($username) {
    if (isBanned($username)) {
        logoutUser($username);
        return false; // Зупиняє наступні слухачі
    }
});
Flight::onEvent('user.login', function ($username) {
    sendWelcomeEmail($username); // цього ніколи не відправляється
});
```

## Переопределення методів подій

`Flight::onEvent()` та `Flight::triggerEvent()` доступні для [розширення](/learn/extending), що означає, що ви можете переопределити їхню роботу. Це чудово для просунутих користувачів, які хочуть налаштувати систему подій, наприклад, додати логування або змінити спосіб, яким події розсилаються.

### Приклад: Кастомізація `onEvent`
```php
Flight::map('onEvent', function (string $event, callable $callback) {
    // Логувати кожну реєстрацію події
    error_log("Додано новий слухач події для: $event");
    // Викликати стандартну поведінку (припускаючи внутрішню систему подій)
    Flight::_onEvent($event, $callback);
});
```
Тепер кожного разу, коли ви реєструєте подію, вона логуватим це перед тим, як продовжити.

### Чому перевизначати?
- Додати налагодження або моніторинг.
- Обмежити події в певних середовищах (наприклад, відключити в тестуванні).
- Інтегрувати з іншою бібліотекою подій.

## Де реєструвати ваші події

Як новачок, ви, можливо, будете запитувати: *де мені реєструвати всі ці події в моєму додатку?* Простота Flight означає, що немає строгих правил — ви можете розмістити їх де завгодно, що має сенс для вашого проекту. Однак організація допоможе вам підтримувати ваш код у міру зростання вашого додатку. Ось кілька практичних варіантів та найкращих практик, спеціально адаптованих до легкої природи Flight:

### Варіант 1: У вашому основному `index.php`
Для невеликих додатків або швидких прототипів ви можете реєструвати події прямо у вашому файлі `index.php` поряд з вашими маршрутами. Це утримує все в одному місці, що добре, коли простота є вашим пріоритетом.

```php
require 'vendor/autoload.php';

// Реєстрація подій
Flight::onEvent('user.login', function ($username) {
    error_log("$username увійшов в систему о " . date('Y-m-d H:i:s'));
});

// Визначення маршрутів
Flight::route('/login', function () {
    $username = 'bob';
    Flight::triggerEvent('user.login', $username);
    echo "Увійшли!";
});

Flight::start();
```
- **Плюси**: Просто, немає додаткових файлів, чудово для невеликих проектів.
- **Мінуси**: Може стати заплутаним, коли ваш додаток розвивається з багатьма подіями та маршрутами.

### Варіант 2: Окремий файл `events.php`
Для трохи більшого додатку розгляньте можливість перемістити реєстрацію подій у спеціальний файл, наприклад `app/config/events.php`. Включіть цей файл у вашому `index.php` перед маршрутами. Це імітує організацію, якою часто користуються маршрути в `app/config/routes.php` у проектах Flight.

```php
// app/config/events.php
Flight::onEvent('user.login', function ($username) {
    error_log("$username увійшов в систему о " . date('Y-m-d H:i:s'));
});

Flight::onEvent('user.registered', function ($email, $name) {
    echo "Електронний лист надіслано на $email: Ласкаво просимо, $name!";
});
```

```php
// index.php
require 'vendor/autoload.php';
require 'app/config/events.php';

Flight::route('/login', function () {
    $username = 'bob';
    Flight::triggerEvent('user.login', $username);
    echo "Увійшли!";
});

Flight::start();
```
- **Плюси**: Зберігає `index.php` зосередженим на маршрутах, організовує події логічно, легко знайти та редагувати.
- **Мінуси**: Додає трохи структури, що може відчуватися як зайве для дуже маленьких додатків.

### Варіант 3: Біля тих, що їх викликають
Ще один підхід — реєструвати події близько до того, де їх викликають, наприклад, всередині контролера або визначення маршруту. Це добре працює, якщо подія специфічна для однієї частини вашого додатку.

```php
Flight::route('/signup', function () {
    // Реєстрація події тут
    Flight::onEvent('user.registered', function ($email) {
        echo "Відправлено вітальний електронний лист на $email!";
    });

    $email = 'jane@example.com';
    Flight::triggerEvent('user.registered', $email);
    echo "Зареєстровані!";
});
```
- **Плюси**: Тримає пов'язаний код разом, добре для ізольованих функцій.
- **Мінуси**: Розсіює реєстрацію подій, ускладнюючи перегляд всіх подій одночасно; ризики повторних реєстрацій, якщо не бути обережним.

### Найкраща практика для Flight
- **Почніть з простого**: Для маленьких додатків помістіть події в `index.php`. Це швидко і узгоджується з мінімалізмом Flight.
- **Розвивайтеся розумно**: Коли ваш додаток зростає (наприклад, більше 5-10 подій), використовуйте файл `app/config/events.php`. Це природний крок уперед, подібно до організації маршрутів, і підтримує ваш код акуратним без додавання складних фреймворків.
- **Уникайте надмірного інженерства**: Не створюйте повноцінний клас або директорію "менеджера подій", якщо ваш додаток не став величезним — Flight розвивається за простотою, тому тримайте його легким.

### Порада: Групуйте за призначенням
У файлі `events.php` групуйте пов'язані події (наприклад, всі події, пов'язані з користувачами, разом) з коментарями для ясності:

```php
// app/config/events.php
// Події користувачів
Flight::onEvent('user.login', function ($username) {
    error_log("$username увійшов в систему");
});
Flight::onEvent('user.registered', function ($email) {
    echo "Ласкаво просимо до $email!";
});

// Події сторінок
Flight::onEvent('page.updated', function ($pageId) {
    unset($_SESSION['pages'][$pageId]);
});
```

Ця структура добре масштабується і залишається дружньою до новачків.

## Приклади для новачків

Давайте пройдемося через кілька реальних сценаріїв, щоб показати, як працюють події і чому вони корисні.

### Приклад 1: Логування входу користувача
```php
// Крок 1: Реєстрація слухача
Flight::onEvent('user.login', function ($username) {
    $time = date('Y-m-d H:i:s');
    error_log("$username увійшов в систему о $time");
});

// Крок 2: Виклик його у вашому додатку
Flight::route('/login', function () {
    $username = 'bob'; // Припустимо, що це приходить з форми
    Flight::triggerEvent('user.login', $username);
    echo "Привіт, $username!";
});
```
**Чому це корисно**: Код входу не повинен знати про логування — він просто викликає подію. Ви можете пізніше додати більше слухачів (наприклад, надіслати вітальний електронний лист) без зміни маршруту.

### Приклад 2: Сповіщення про нових користувачів
```php
// Слухач для нових реєстрацій
Flight::onEvent('user.registered', function ($email, $name) {
    // Симулювати відправлення електронного листа
    echo "Електронний лист надіслано на $email: Ласкаво просимо, $name!";
});

// Виклик його, коли хтось підписується
Flight::route('/signup', function () {
    $email = 'jane@example.com';
    $name = 'Jane';
    Flight::triggerEvent('user.registered', $email, $name);
    echo "Дякуємо за підписку!";
});
```
**Чому це корисно**: Логіка підписки фокусується на створенні користувача, тоді як подія обробляє сповіщення. Ви могли б додати більше слухачів (наприклад, логувати підписку) пізніше.

### Приклад 3: Очищення кешу
```php
// Слухач для очищення кешу
Flight::onEvent('page.updated', function ($pageId) {
    unset($_SESSION['pages'][$pageId]); // Очистити кеш сесії, якщо це застосовно
    echo "Кеш очищено для сторінки $pageId.";
});

// Виклик, коли сторінка редагується
Flight::route('/edit-page/(@id)', function ($pageId) {
    // Припустимо, що ми оновили сторінку
    Flight::triggerEvent('page.updated', $pageId);
    echo "Сторінка $pageId оновлена.";
});
```
**Чому це корисно**: Код редагування не піклується про кешування — він просто сигналізує про оновлення. Інші частини програми можуть реагувати за потреби.

## Найкращі практики

- **Чітко називайте події**: Використовуйте специфічні назви, як `'user.login'` або `'page.updated'`, щоб було зрозуміло, що вони роблять.
- **Зберігайте слухачів простими**: Не ставте повільні або складні завдання в слухачі — тримайте ваш додаток швидким.
- **Тестуйте ваші події**: Викликайте їх вручну, щоб переконатися, що слухачі працюють, як очікувалося.
- **Використовуйте події мудро**: Вони чудово підходять для декуплювання, але надто велика їх кількість може ускладнити ваш код — використовуйте їх, коли це має сенс.

Система подій у Flight PHP, з `Flight::onEvent()` та `Flight::triggerEvent()`, надає вам простий, але потужний спосіб створення гнучких додатків. Дозволяючи різним частинам вашого додатку спілкуватися одна з одною через події, ви можете зберегти свій код організованим, повторно використовуваним і легким для розширення. Незалежно від того, чи ви логгеруєте дії, надсилаєте сповіщення чи керуєте оновленнями, події допомагають вам робити це без заплутування вашої логіки. Крім того, з можливістю переопределення цих методів, у вас є свобода налаштувати систему відповідно до ваших потреб. Починайте з малого з однією подією і спостерігайте, як це трансформує структуру вашого додатку!

## Вбудовані події

Flight PHP постачає кілька вбудованих подій, які ви можете використовувати для підключення до життєвого циклу фреймворка. Ці події викликаються в певні моменти циклу запиту/відповіді, що дозволяє вам виконувати користувацьку логіку, коли трапляються певні дії.

### Список вбудованих подій
- **flight.request.received**: `function(Request $request)` Викликається, коли запит отримано, проаналізовано та оброблено.
- **flight.error**: `function(Throwable $exception)` Викликається, коли під час життєвого циклу запиту виникає помилка.
- **flight.redirect**: `function(string $url, int $status_code)` Викликається, коли ініціюється перенаправлення.
- **flight.cache.checked**: `function(string $cache_key, bool $hit, float $executionTime)` Викликається, коли кеш перевіряється для певного ключа та вказує, чи був кешований або пропущений.
- **flight.middleware.before**: `function(Route $route)` Викликається після виконання перед середнього програмного забезпечення.
- **flight.middleware.after**: `function(Route $route)` Викликається після виконання після середнього програмного забезпечення.
- **flight.middleware.executed**: `function(Route $route, $middleware, string $method, float $executionTime)` Викликається після виконання будь-якого середнього програмного забезпечення.
- **flight.route.matched**: `function(Route $route)` Викликається, коли маршрут співпадає, але ще не запускається.
- **flight.route.executed**: `function(Route $route, float $executionTime)` Викликається після виконання та обробки маршруту. `$executionTime` — це час, необхідний для виконання маршруту (виклику контролера тощо).
- **flight.view.rendered**: `function(string $template_file_path, float $executionTime)` Викликається після рендерингу подання. `$executionTime` — це час, необхідний для рендерингу шаблону. **Примітка: якщо ви переопределите метод `render`, вам потрібно буде повторно викликати цю подію.**
- **flight.response.sent**: `function(Response $response, float $executionTime)` Викликається після відправлення відповіді клієнту. `$executionTime` — це час, необхідний для побудови відповіді.