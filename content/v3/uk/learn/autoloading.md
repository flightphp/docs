# Автозавантаження

## Огляд

Автозавантаження — це концепція в PHP, де ви вказуєте каталог або каталоги для завантаження класів. Це набагато корисніше, ніж використання `require` або `include` для завантаження класів. Це також вимога для використання пакетів Composer.

## Розуміння

За замовчуванням будь-який клас `Flight` автоматично автозавантажується для вас завдяки composer. Однак, якщо ви хочете автозавантажувати власні класи, ви можете використовувати метод `Flight::path()` для вказання каталогу для завантаження класів.

Використання автозавантажувача може значно спростити ваш код. Замість того, щоб файли починалися з безлічі операторів `include` або `require` на вершині для захоплення всіх класів, які використовуються в цьому файлі, ви можете динамічно викликати свої класи, і вони будуть включені автоматично.

## Основне використання

Припустимо, у нас є дерево каталогів, як у наведеному нижче:

```text
# Приклад шляху
/home/user/project/my-flight-project/
├── app
│   ├── cache
│   ├── config
│   ├── controllers - містить контролери для цього проекту
│   ├── translations
│   ├── UTILS - містить класи лише для цієї програми (це все великими літерами навмисно для прикладу пізніше)
│   └── views
└── public
    └── css
	└── js
	└── index.php
```

Ви могли помітити, що це та сама структура файлів, як у цьому сайті документації.

Ви можете вказати кожен каталог для завантаження таким чином:

```php

/**
 * public/index.php
 */

// Додати шлях до автозавантажувача
Flight::path(__DIR__.'/../app/controllers/');
Flight::path(__DIR__.'/../app/utils/');


/**
 * app/controllers/MyController.php
 */

// простори імен не потрібні

// Усі автозавантажені класи рекомендується називати в стилі Pascal Case (кожне слово з великої літери, без пробілів)
class MyController {

	public function index() {
		// зробити щось
	}
}
```

## Простори імен

Якщо у вас є простори імен, це насправді стає дуже легко реалізувати. Ви повинні використовувати метод `Flight::path()` для вказання кореневого каталогу (не кореня документа чи папки `public/`) вашої програми.

```php

/**
 * public/index.php
 */

// Додати шлях до автозавантажувача
Flight::path(__DIR__.'/../');
```

Тепер ось як може виглядати ваш контролер. Подивіться на приклад нижче, але зверніть увагу на коментарі для важливої інформації.

```php
/**
 * app/controllers/MyController.php
 */

// простори імен обов'язкові
// простори імен такі ж, як структура каталогу
// простори імен повинні відповідати регістру структури каталогу
// простори імен і каталоги не можуть містити підкреслення (якщо не встановлено Loader::setV2ClassLoading(false))
namespace app\controllers;

// Усі автозавантажені класи рекомендується називати в стилі Pascal Case (кожне слово з великої літери, без пробілів)
// Починаючи з 3.7.2, ви можете використовувати Pascal_Snake_Case для назв класів, запустивши Loader::setV2ClassLoading(false);
class MyController {

	public function index() {
		// зробити щось
	}
}
```

А якщо ви хочете автозавантажити клас у каталозі utils, ви б зробили по суті те саме:

```php

/**
 * app/UTILS/ArrayHelperUtil.php
 */

// простір імен повинен відповідати структурі каталогу та регістру (зауважте, що каталог UTILS всі великими літерами
//     як у дереві файлів вище)
namespace app\UTILS;

class ArrayHelperUtil {

	public function changeArrayCase(array $array) {
		// зробити щось
	}
}
```

## Підкреслення в назвах класів

Починаючи з 3.7.2, ви можете використовувати Pascal_Snake_Case для назв класів, запустивши `Loader::setV2ClassLoading(false);`. 
Це дозволить вам використовувати підкреслення в назвах класів. 
Це не рекомендується, але доступно для тих, хто в цьому потребує.

```php
use flight\core\Loader;

/**
 * public/index.php
 */

// Додати шлях до автозавантажувача
Flight::path(__DIR__.'/../app/controllers/');
Flight::path(__DIR__.'/../app/utils/');
Loader::setV2ClassLoading(false);

/**
 * app/controllers/My_Controller.php
 */

// простори імен не потрібні

class My_Controller {

	public function index() {
		// зробити щось
	}
}
```

## Дивіться також
- [Маршрутизація](/learn/routing) - Як відображати маршрути на контролери та рендерити представлення.
- [Чому фреймворк?](/learn/why-frameworks) - Розуміння переваг використання фреймворку, як Flight.

## Вирішення проблем
- Якщо ви не можете з'ясувати, чому ваші класи з просторами імен не знаходяться, пам'ятайте використовувати `Flight::path()` до кореневого каталогу у вашому проекті, не до вашого каталогу `app/` чи `src/` або еквівалента.

### Клас не знайдено (автозавантаження не працює)

Для цього може бути кілька причин. Нижче наведено деякі приклади, але переконайтеся, що ви також переглянули розділ [автозавантаження](/learn/autoloading).

#### Неправильна назва файлу
Найпоширеніша — назва класу не відповідає назві файлу.

Якщо у вас є клас з назвою `MyClass`, то файл повинен називатися `MyClass.php`. Якщо у вас є клас з назвою `MyClass`, а файл називається `myclass.php` 
тоді автозавантажувач не зможе його знайти.

#### Неправильний простір імен
Якщо ви використовуєте простори імен, то простір імен повинен відповідати структурі каталогу.

```php
// ...code...

// якщо ваш MyController знаходиться в каталозі app/controllers і він має простір імен
// це не працюватиме.
Flight::route('/hello', 'MyController->hello');

// вам потрібно обрати один з цих варіантів
Flight::route('/hello', 'app\controllers\MyController->hello');
// або якщо у вас є оператор use на вершині

use app\controllers\MyController;

Flight::route('/hello', [ MyController::class, 'hello' ]);
// також може бути написано
Flight::route('/hello', MyController::class.'->hello');
// також...
Flight::route('/hello', [ 'app\controllers\MyController', 'hello' ]);
```

#### `path()` не визначено

У скелетному додатку це визначено всередині файлу `config.php`, але для того, щоб ваші класи були знайдені, вам потрібно переконатися, що метод `path()`
визначено (ймовірно, до кореня вашого каталогу) перед тим, як ви спробуєте його використовувати.

```php
// Додати шлях до автозавантажувача
Flight::path(__DIR__.'/../');
```

## Журнал змін
- v3.7.2 - Ви можете використовувати Pascal_Snake_Case для назв класів, запустивши `Loader::setV2ClassLoading(false);`
- v2.0 - Додано функціональність автозавантаження.